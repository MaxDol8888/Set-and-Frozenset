# Set-and-Frozenset
Множества (set и frozenset)

Множество в языке Python — это структура данных, эквивалентная множествам в математике. Множество может состоять из различных элементов, порядок элементов в множестве не определён. В множество можно добавлять и удалять элементы, можно перебирать элементы множества, можно выполнять операции над множествами (объединение, пересечение, разность). Можно проверять принадлежность элементу множества.
В отличии от массивов, где элементы хранятся в виде последовательного списка, в множествах порядок хранения элементов не определён (более того, элементы множества хранятся не подряд, как в списке, а при помощи хитрых алгоритмов). Это позволяет выполнять операции типа “проверить принадлежность элемента множеству” быстрее, чем просто перебирая все элементы множества.
Элементами множества может быть любой неизменяемый тип данных: числа, строки, кортежи. Изменяемые типы данных не могут быть элементами множества, в частности, нельзя сделать элементом множества список (но можно сделать кортеж) или другое множество. Требование неизменяемости элементов множества накладывается особенностями представления множества в памяти компьютера.
Задание множеств
Множество задается перечислением всех его элементов в фигурных скобках. Например:
A = {1, 2, 3}
Исключением является пустое множество, которое можно создать при помощи функции set(). Если функции set передать в качестве параметра список, строку или кортеж, то она вернет множество, составленное из элементов списка, строки, кортежа. Например:
A = set('qwerty')
print(A)
выведет {'e', 'q', 'r', 't', 'w', 'y'}.
a = set()

a = set('hello')
>>> a
{'h', 'o', 'l', 'e'}

Каждый элемент может входить в множество только один раз, порядок задания элементов не важен. Например, программа:
A = {1, 2, 3}
B = {3, 2, 3, 1}
print(A == B)
выведет True, так как A и B — равные множества.
Каждый элемент может входить в множество только один раз. set('Hello') вернет множество из четырех элементов: {'H', 'e', 'l', 'o'}.

a = {i ** 2 for i in range(10)} # генератор множеств
>>> a
{0, 1, 4, 81, 64, 9, 16, 49, 25, 36}
Работа с элементами множеств
Узнать число элементов в множестве можно при помощи функции len.
Перебрать все элементы множества (в неопределенном порядке!) можно при помощи цикла for:
C = {1, 2, 3, 4, 5}
for elem in C:
    print(elem)
Проверить, принадлежит ли элемент множеству можно при помощи операции in, возвращающей значение типа bool:
i in A
Аналогично есть противоположная операция not in.
Для добавления элемента в множество есть метод add:
A.add(x)
Для удаления элемента x из множества есть два метода: discard и remove. Их поведение различается только в случае, когда удаляемый элемент отсутствует в множестве. В этом случае метод discard не делает ничего, а метод remove генерирует исключение KeyError.
Наконец, метод pop удаляет из множества один случайный элемент и возвращает его значение. Если же множество пусто, то генерируется исключение KeyError.
Из множества можно сделать список при помощи функции list.
Перебор элементов множества
При помощи цикла for можно перебрать все элементы множества:
Primes = {2, 3, 5, 7, 11}
for num im Primes:
    print(num)
Операции с множествами
С множествами в питоне можно выполнять обычные для математики операции над множествами.
A.isdisjoint(B)	true, если A и B не имеют общих элементов
A == B	Все элементы A принадлежат B, все элементы B принадлежат A
A.copy()	Копия множества
A.add(elem)	Добавляет элемент в множество
A.remove(elem)	Удаляет элемент из множества. KeyError, если такого элемента не существует
A.discard(elem)	Удаляет элемент, если он находится в множестве
A.pop()	Удаляет первый элемент из множества. Так как множества не упорядочены, нельзя точно сказать, какой элемент будет первым
A.clear()	Очистка множества
A | B
A.union(B)
	Возвращает множество, являющееся объединением множеств A и B.
A |= B
A.update(B)
	Добавляет в множество A все элементы из множества B.
A & B
A.intersection(B)
	Возвращает множество, являющееся пересечением множеств A и B.
A &= B
A.intersection_update(B)
	Оставляет в множестве A только те элементы, которые есть в множестве B.
A - B
A.difference(B)
	Возвращает разность множеств A и B (элементы, входящие в A, но не входящие в B).
A -= B
A.difference_update(B)
	Удаляет из множества A все элементы, входящие в B.
A ^ B
A.symmetric_difference(B)
	Возвращает симметрическую разность множеств A и B (элементы, входящие в A или в B, но не в оба из них одновременно).
A ^= B
A.symmetric_difference_update(B)
	Записывает в A симметрическую разность множеств A и B.
A <= B
A.issubset(B)
	Возвращает true, если A является подмножеством B.
A >= B
A.issuperset(B)
	Возвращает true, если B является подмножеством A.
A < B
	Эквивалентно A <= B and A != B
A > B
	Эквивалентно A >= B and A != B

Built-in Functions with Set
Built-in functions like all(), any(), enumerate(), len(), max(), min(), sorted(), sum() etc. are commonly used with set to perform different tasks.

Built-in Functions with Set
Function	Description
all()
Return True if all elements of the set are true (or if the set is empty).
any()
Return True if any element of the set is true. If the set is empty, return False.
enumerate()
Return an enumerate object. It contains the index and value of all the items of set as a pair.
len()
Return the length (the number of items) in the set.
max()
Return the largest item in the set.
min()
Return the smallest item in the set.
sorted()
Return a new sorted list from elements in the set (does not sort the set itself).
sum()
Retrun the sum of all elements in the set.



frozenset
Единственное отличие set от frozenset заключается в том, что set - изменяемый тип данных, а frozenset - нет. Примерно похожая ситуация со списками и кортежами.

Изменяемые наборы не подлежат изменению, поэтому их нельзя использовать в качестве ключей словаря. С другой стороны, frozensets являются хэшируемыми и могут использоваться как ключи к словарю.
Frozenset может быть создан с помощью функции frozenset () .
Этот тип данных поддерживает такие методы, как copy(), difference(), intersection(), isdisjoint(), issubset(), issuperset(), symmetric_difference()и union(). Будучи неизменным, он не имеет метода добавления или удаления элементов.
